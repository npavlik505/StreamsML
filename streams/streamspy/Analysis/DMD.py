# TODO: Does not yet account for non-uniform grid and compressible flow. Reference POD code.  

"""Dynamic Mode Decomposition utilities."""

from pathlib import Path
import numpy as np
import h5py
import matplotlib.pyplot as plt


def run_dmd(sa_path: Path, output_dir: Path) -> Path:
    """Compute DMD modes from ``span_averages.h5`` and write them to ``output_dir``.

    Parameters
    ----------
    sa_path: Path
        Path to ``span_averages.h5`` generated by the solver.
    output_dir: Path
        Directory where the DMD results will be stored.

    Returns
    -------
    Path
        The path to the created ``dmd_results.h5`` file.
    """

    with h5py.File(sa_path, "r") as f:
        sa = f["span_average"][:]  # shape (num_snaps, 5, nx, ny)
        time = f["time"][:]

    num_snaps = sa.shape[0]

    # flatten all flowfield components for each snapshot
    data = sa.reshape(num_snaps, -1).T  # shape (state_dim, num_snaps)

    if num_snaps < 2:
        raise ValueError("Need at least two snapshots for DMD")

    X1 = data[:, :-1]
    X2 = data[:, 1:]

    U, s, Vh = np.linalg.svd(X1, full_matrices=False)
    A_tilde = U.T.conj() @ X2 @ Vh.T.conj() / s
    eigvals, W = np.linalg.eig(A_tilde)
    Phi = X2 @ Vh.T.conj() / s @ W

    b = np.linalg.lstsq(Phi, data[:, 0], rcond=None)[0]

    output_dir.mkdir(parents=True, exist_ok=True)
    out_file = output_dir / "dmd_results.h5"
    with h5py.File(out_file, "w") as f:
        f.create_dataset("modes", data=Phi)
        f.create_dataset("eigenvalues", data=eigvals)
        f.create_dataset("amplitudes", data=b)
        f.create_dataset("time", data=time)

    print(f"DMD results written to {out_file}")
    return out_file


def _eigenvalue_label(value: complex, has_conjugate: bool) -> str:
    """Return a human-friendly label for an eigenvalue.

    If ``has_conjugate`` is ``True`` the imaginary component is shown with a
    ``±`` sign to indicate the presence of a conjugate pair.
    """

    real = float(np.real(value))
    imag = float(np.imag(value))
    if np.isclose(imag, 0.0):
        return f"{real:.4g}"

    imag_mag = abs(imag)
    if has_conjugate:
        return f"{real:.4g} ± {imag_mag:.4g}i"
    sign = "+" if imag >= 0 else "-"
    return f"{real:.4g} {sign} {imag_mag:.4g}i"


def _group_conjugate_modes(
    eigenvalues: np.ndarray, indices: list[int], atol: float = 1e-10, rtol: float = 1e-7
) -> list[tuple[int, int | None, str]]:
    """Group mode indices into unique eigenvalue entries.

    Parameters
    ----------
    eigenvalues : np.ndarray
        Full array of eigenvalues.
    indices : list[int]
        Indices that should be considered for plotting.
    atol, rtol : float, optional
        Absolute and relative tolerances for detecting conjugate pairs via
        :func:`numpy.isclose`.

    Returns
    -------
    list of tuples
        Each tuple contains ``(primary_idx, conjugate_idx_or_None, label)``
        where ``primary_idx`` is the representative mode index, optionally
        paired with its conjugate, and ``label`` is the display string for the
        eigenvalue.
    """

    used: set[int] = set()
    grouped: list[tuple[int, int | None, str]] = []
    for idx in indices:
        if idx in used:
            continue

        value = eigenvalues[idx]
        conj_idx: int | None = None
        for other in indices:
            if other == idx or other in used:
                continue
            if np.isclose(value, np.conj(eigenvalues[other]), atol=atol, rtol=rtol):
                conj_idx = other
                break

        label = _eigenvalue_label(value, has_conjugate=conj_idx is not None)
        grouped.append((idx, conj_idx, label))
        used.add(idx)
        if conj_idx is not None:
            used.add(conj_idx)

    return grouped


def plot_dmd_modes(
    results_path: Path,
    nx: int,
    ny: int,
    n_comp: int = 5,
    components: list[int] | tuple[int, ...] | None = None,
    cmap: str = "viridis",
    grid: tuple[np.ndarray, np.ndarray] | None = None,
    atol: float = 1e-10,
    rtol: float = 1e-7,
):
    """Plot DMD spatial modes without duplicating conjugate pairs.

    Parameters
    ----------
    results_path : Path
        Path to ``dmd_results.h5`` written by :func:`run_dmd`.
    nx, ny : int
        Grid dimensions used to reshape each spatial mode.
    n_comp : int, optional
        Number of flow-field components contained in each snapshot; defaults to
        ``5`` (``ρ, u, v, w, p`` for compressible flows).
    components : list[int] or tuple[int], optional
        Subset of component indices to plot. Defaults to ``None`` which plots
        all components.
    cmap : str, optional
        Colormap passed to Matplotlib.
    grid : tuple[np.ndarray, np.ndarray], optional
        Optional 1D ``(xg, yg)`` coordinate arrays; enables ``pcolormesh``
        plotting on the physical grid.
    atol, rtol : float, optional
        Tolerances for identifying conjugate eigenvalue pairs.

    Returns
    -------
    fig, axes, conjugate_checks : Figure, np.ndarray, dict[str, bool]
        Matplotlib handles and a mapping from eigenvalue label to a boolean
        indicating whether the magnitudes of each conjugate pair matched.
    """

    with h5py.File(results_path, "r") as f:
        modes = f["modes"][:]  # (features, n_modes)
        eigenvalues = f["eigenvalues"][:]

    expected_features = n_comp * nx * ny
    if modes.shape[0] != expected_features:
        raise ValueError(
            f"Mode array has {modes.shape[0]} rows but expected {expected_features} for {n_comp} components and grid {nx}x{ny}."
        )

    available_modes = modes.shape[1]
    mode_indices = list(range(available_modes))

    if components is None:
        comp_indices = list(range(n_comp))
    else:
        comp_indices = list(components)
        if any(idx < 0 or idx >= n_comp for idx in comp_indices):
            raise ValueError(f"Component indices must lie in [0, {n_comp}); got {components}.")

    unique_modes = _group_conjugate_modes(eigenvalues, mode_indices, atol=atol, rtol=rtol)
    n_cols = len(unique_modes)
    n_rows = len(comp_indices)
    fig, axes = plt.subplots(n_rows, n_cols, figsize=(4 * n_cols, 3 * n_rows), squeeze=False)

    if grid is not None:
        xg, yg = grid
        if xg.shape[0] != nx or yg.shape[0] != ny:
            raise ValueError("Grid vectors must match nx and ny when provided.")
        Xg, Yg = np.meshgrid(xg, yg, indexing="ij")
        plot_fn = lambda ax, data: ax.pcolormesh(Xg, Yg, data, shading="auto", cmap=cmap)
    else:
        plot_fn = lambda ax, data: ax.imshow(data.T, origin="lower", cmap=cmap)

    conjugate_checks: dict[str, bool] = {}
    for col, (idx, conj_idx, label) in enumerate(unique_modes):
        mode_field = np.abs(modes[:, idx]).reshape(n_comp, nx, ny, order="C")
        conj_match = True
        if conj_idx is not None:
            conj_field = np.abs(modes[:, conj_idx]).reshape(n_comp, nx, ny, order="C")
            conj_match = bool(np.allclose(mode_field, conj_field, atol=atol, rtol=rtol))
            conjugate_checks[label] = conj_match

        for row, comp_idx in enumerate(comp_indices):
            ax = axes[row, col]
            im = plot_fn(ax, mode_field[comp_idx])
            comp_label = f"component {comp_idx}"
            ax.set_title(f"Mode {idx} (λ={label})\n|φ|; conj match: {conj_match}")
            fig.colorbar(im, ax=ax)
            if grid is not None:
                ax.set_xlabel("x")
                ax.set_ylabel("y")

    fig.tight_layout()
    return fig, axes, conjugate_checks
